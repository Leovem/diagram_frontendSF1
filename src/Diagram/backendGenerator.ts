// backendGenerator.ts
import JSZip from "jszip";
import { saveAs } from "file-saver";

/** ====== Tipos de entrada desde tu normalizador ====== */
export type UmlAttribute = { name: string; type?: string; multiplicity?: string };
export type UmlOperation = { name: string; params?: { name: string; type?: string }[]; returnType?: string };
export type UmlClass = { id: string; name: string; attributes: UmlAttribute[]; operations: UmlOperation[] };

export type RelationshipKind = "association" | "aggregation" | "composition" | "generalization" | "dependency";
export type Relationship = { id: string; sourceId: string; targetId: string; kind: RelationshipKind };

export type Model = { classes: UmlClass[]; rels: Relationship[] };

type Options = {
  groupId?: string;
  artifactId?: string;
  version?: string;
  packageBase?: string; // e.g. "com.example.app"
  javaVersion?: string; // "17"
  db?: "h2" | "postgres";
};

const DEFAULT_OPTS: Required<Options> = {
  groupId: "com.example",
  artifactId: "app",
  version: "0.0.1-SNAPSHOT",
  packageBase: "com.example.app",
  javaVersion: "17",
  db: "h2",
} as const;

/** ====== Utilidades ====== */
const kebab = (s: string) =>
  s.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();

const cap1 = (s: string) => (s ? s[0].toUpperCase() + s.slice(1) : s);

function javaType(umlType?: string): string {
  if (!umlType) return "String";
  const t = umlType.toLowerCase();
  if (["int", "integer"].includes(t)) return "Integer";
  if (["long"].includes(t)) return "Long";
  if (["double"].includes(t)) return "Double";
  if (["float"].includes(t)) return "Float";
  if (["number", "decimal", "bigdecimal"].includes(t)) return "BigDecimal";
  if (["boolean", "bool"].includes(t)) return "Boolean";
  if (["date"].includes(t)) return "LocalDate";
  if (["datetime", "timestamp"].includes(t)) return "LocalDateTime";
  return "String";
}

function inferRelationByKind(kind: RelationshipKind, multA?: string, multB?: string) {
  // Devuelve {aSide: 'ONE'|'MANY', bSide: 'ONE'|'MANY', type: 'ONE_TO_MANY'|'MANY_TO_ONE'|'ONE_TO_ONE'|'MANY_TO_MANY'}
  // Heurística por multiplicidad si existe
  const parseMult = (m?: string) => {
    if (!m) return "*"; // por defecto many
    return m.replace(/\s/g, "");
  };
  const A = parseMult(multA);
  const B = parseMult(multB);

  const card = (m: string) => (m === "1" || m === "0..1" || m === "1..1" ? "ONE" : "MANY");

  // Si hay multiplicidades claras, priorizarlas
  if (A && B) {
    const a = card(A);
    const b = card(B);
    if (a === "ONE" && b === "ONE") return { aSide: "ONE", bSide: "ONE", type: "ONE_TO_ONE" as const };
    if (a === "ONE" && b === "MANY") return { aSide: "ONE", bSide: "MANY", type: "ONE_TO_MANY" as const };
    if (a === "MANY" && b === "ONE") return { aSide: "MANY", bSide: "ONE", type: "MANY_TO_ONE" as const };
    return { aSide: "MANY", bSide: "MANY", type: "MANY_TO_MANY" as const };
  }

  // Si no hay multiplicidad, usar heurística por kind
  switch (kind) {
    case "generalization":
      // Herencia, se maneja aparte.
      return { aSide: "ONE", bSide: "ONE", type: "ONE_TO_ONE" as const };
    case "composition":
    case "aggregation":
      return { aSide: "ONE", bSide: "MANY", type: "ONE_TO_MANY" as const };
    case "association":
    case "dependency":
    default:
      return { aSide: "MANY", bSide: "ONE", type: "MANY_TO_ONE" as const };
  }
}

/** ====== Plantillas ====== */
function tplPomXml(opts: Required<Options>): string {
  const depsDb =
    opts.db === "postgres"
      ? `
    <dependency>
      <groupId>org.postgresql</groupId>
      <artifactId>postgresql</artifactId>
      <scope>runtime</scope>
    </dependency>`
      : `
    <dependency>
      <groupId>com.h2database</groupId>
      <artifactId>h2</artifactId>
      <scope>runtime</scope>
    </dependency>`;

  return `<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>${opts.groupId}</groupId>
  <artifactId>${opts.artifactId}</artifactId>
  <version>${opts.version}</version>
  <name>${opts.artifactId}</name>
  <description>Generated by CASE</description>
  <properties>
    <java.version>${opts.javaVersion}</java.version>
    <spring-boot.version>3.3.2</spring-boot.version>
  </properties>

  <dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-dependencies</artifactId>
        <version>\${spring-boot.version}</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
    </dependencies>
  </dependencyManagement>

  <dependencies>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    ${depsDb}
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>

    <!-- Opcional: mapper manual, sin Lombok ni MapStruct para evitar dependencias -->
    <!-- Agrega Lombok si lo deseas -->
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
      </plugin>
    </plugins>
  </build>
</project>`;
}

function tplApplicationProperties(opts: Required<Options>): string {
  if (opts.db === "postgres") {
    return `spring.datasource.url=jdbc:postgresql://localhost:5432/${opts.artifactId}
spring.datasource.username=postgres
spring.datasource.password=postgres
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
server.port=8080`;
  }
  return `spring.datasource.url=jdbc:h2:mem:${opts.artifactId};DB_CLOSE_DELAY=-1;MODE=PostgreSQL
spring.datasource.driverClassName=org.h2.Driver
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.h2.console.enabled=true
server.port=8080`;
}

function tplApplicationClass(pkg: string): string {
  return `package ${pkg};

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class AppApplication {
  public static void main(String[] args) {
    SpringApplication.run(AppApplication.class, args);
  }
}`;
}

function tplEntity(pkg: string, cls: UmlClass, relFields: string[], isBaseOfInheritance: boolean): string {
  // Atributos simples
  const fields = cls.attributes.map(a => `  private ${javaType(a.type)} ${a.name};`).join("\n");

  const inheritance = isBaseOfInheritance
    ? "\n@Inheritance(strategy = jakarta.persistence.InheritanceType.JOINED)"
    : "";

  return `package ${pkg}.domain;

import jakarta.persistence.*;
import java.math.BigDecimal;
import java.time.*;

@Entity
${inheritance}
public class ${cls.name}${/* 'extends Base' etc se agrega en composicion */""} {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

${fields ? fields + "\n" : ""}${relFields.length ? relFields.join("\n") + "\n" : ""}

  public Long getId() { return id; }
  public void setId(Long id) { this.id = id; }
${cls.attributes.map(a => `
  public ${javaType(a.type)} get${cap1(a.name)}() { return ${a.name}; }
  public void set${cap1(a.name)}(${javaType(a.type)} ${a.name}) { this.${a.name} = ${a.name}; }`).join("")}
}
`;
}

function tplRepository(pkg: string, name: string): string {
  return `package ${pkg}.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import ${pkg}.domain.${name};

public interface ${name}Repository extends JpaRepository<${name}, Long> { }
`;
}

function tplDto(pkg: string, cls: UmlClass, dtoRelFields: string[]): string {
  const fields = cls.attributes.map(a => `  private ${javaType(a.type)} ${a.name};`).join("\n");
  return `package ${pkg}.dto;

import java.util.*;

public class ${cls.name}Dto {
  private Long id;
${fields ? fields + "\n" : ""}${dtoRelFields.length ? dtoRelFields.join("\n") + "\n" : ""}

  public Long getId() { return id; }
  public void setId(Long id) { this.id = id; }
${cls.attributes.map(a => `
  public ${javaType(a.type)} get${cap1(a.name)}() { return ${a.name}; }
  public void set${cap1(a.name)}(${javaType(a.type)} ${a.name}) { this.${a.name} = ${a.name}; }`).join("")}
}
`;
}

function tplMapper(pkg: string, name: string): string {
  // Mapper simple: propiedades escalares; relaciones se resuelven en Service
  return `package ${pkg}.mapper;

import ${pkg}.domain.${name};
import ${pkg}.dto.${name}Dto;

public class ${name}Mapper {
  public static ${name}Dto toDto(${name} e) {
    if (e == null) return null;
    ${name}Dto d = new ${name}Dto();
    d.setId(e.getId());
    // TODO: mapear campos escalares y listas de IDs si agregas relaciones en DTO
    return d;
  }

  public static ${name} toEntity(${name}Dto d) {
    if (d == null) return null;
    ${name} e = new ${name}();
    e.setId(d.getId());
    // TODO: mapear campos escalares
    return e;
  }
}
`;
}

function tplService(pkg: string, name: string): string {
  return `package ${pkg}.service;

import org.springframework.stereotype.Service;
import java.util.*;
import ${pkg}.domain.${name};
import ${pkg}.dto.${name}Dto;
import ${pkg}.mapper.${name}Mapper;
import ${pkg}.repository.${name}Repository;

@Service
public class ${name}Service {
  private final ${name}Repository repo;

  public ${name}Service(${name}Repository repo) {
    this.repo = repo;
  }

  public List<${name}Dto> findAll() {
    return repo.findAll().stream().map(${name}Mapper::toDto).toList();
  }

  public ${name}Dto findById(Long id) {
    return ${name}Mapper.toDto(repo.findById(id).orElseThrow());
  }

  public ${name}Dto create(${name}Dto dto) {
    ${name} saved = repo.save(${name}Mapper.toEntity(dto));
    return ${name}Mapper.toDto(saved);
  }

  public ${name}Dto update(Long id, ${name}Dto dto) {
    ${name} existing = repo.findById(id).orElseThrow();
    // TODO: aplicar cambios de dto -> existing
    ${name} saved = repo.save(existing);
    return ${name}Mapper.toDto(saved);
  }

  public void delete(Long id) {
    repo.deleteById(id);
  }
}
`;
}

function tplController(pkg: string, name: string): string {
  const path = "/api/" + kebab(name);
  return `package ${pkg}.controller;

import org.springframework.web.bind.annotation.*;
import java.util.*;
import ${pkg}.dto.${name}Dto;
import ${pkg}.service.${name}Service;

@RestController
@RequestMapping("${path}")
public class ${name}Controller {

  private final ${name}Service service;

  public ${name}Controller(${name}Service service) {
    this.service = service;
  }

  @GetMapping
  public List<${name}Dto> list() { return service.findAll(); }

  @GetMapping("/{id}")
  public ${name}Dto get(@PathVariable Long id) { return service.findById(id); }

  @PostMapping
  public ${name}Dto create(@RequestBody ${name}Dto dto) { return service.create(dto); }

  @PutMapping("/{id}")
  public ${name}Dto update(@PathVariable Long id, @RequestBody ${name}Dto dto) { return service.update(id, dto); }

  @DeleteMapping("/{id}")
  public void delete(@PathVariable Long id) { service.delete(id); }
}
`;
}

function tplPostmanCollection(baseUrl: string, classNames: string[]) {
  const items = classNames.map((n) => {
    const p = "/api/" + kebab(n);
    return [
      {
        name: `[${n}] List`,
        request: { method: "GET", url: baseUrl + p },
      },
      {
        name: `[${n}] Get by id`,
        request: { method: "GET", url: baseUrl + p + "/{{id}}" },
      },
      {
        name: `[${n}] Create`,
        request: { method: "POST", url: baseUrl + p, body: { mode: "raw", raw: "{}" } },
      },
      {
        name: `[${n}] Update`,
        request: { method: "PUT", url: baseUrl + p + "/{{id}}", body: { mode: "raw", raw: "{}" } },
      },
      {
        name: `[${n}] Delete`,
        request: { method: "DELETE", url: baseUrl + p + "/{{id}}" },
      },
    ];
  }).flat();

  return JSON.stringify({
    info: { name: "CASE Generated API", schema: "https://schema.getpostman.com/json/collection/v2.1.0/collection.json" },
    item: items.map((it: any) => ({ name: it.name, request: it.request })),
    variable: [{ key: "id", value: "1" }],
  }, null, 2);
}

/** ====== Relaciones → campos JPA (simple) ======
 * Generamos sólo miembros en entidades; por simplicidad no generamos lados inversos complejos.
 */
function relationFields(pkg: string, model: Model, cls: UmlClass) {
  // Buscar rels donde participa esta clase
  const byId = Object.fromEntries(model.classes.map(c => [c.id, c]));
  const my = model.rels.filter(r => r.sourceId === cls.id || r.targetId === cls.id);

  const fields: string[] = [];
  const dtoFields: string[] = [];

  for (const r of my) {
    const source = byId[r.sourceId];
    const target = byId[r.targetId];
    if (!source || !target) continue;

    // determinar orientación desde 'cls'
    const iAmSource = r.sourceId === cls.id;
    const other = iAmSource ? target : source;

    // (Para StarUML podrías leer multiplicidad en roles; aquí usamos heurística)
    const { type } = inferRelationByKind(r.kind);

    if (type === "ONE_TO_ONE") {
      // dueño en el lado source
      if (iAmSource) {
        fields.push(`  @OneToOne\n  @JoinColumn(name="${kebab(other.name)}_id")\n  private ${other.name} ${other.name.charAt(0).toLowerCase() + other.name.slice(1)};`);
        dtoFields.push(`  private Long ${kebab(other.name)}Id;`);
      }
    } else if (type === "ONE_TO_MANY") {
      // dueño Many (lado target) tendrá FK -> ManyToOne
      if (iAmSource) {
        // soy ONE -> coleccion
        fields.push(`  @OneToMany(mappedBy="${cls.name.charAt(0).toLowerCase() + cls.name.slice(1)}", cascade = CascadeType.ALL, orphanRemoval = true)\n  private java.util.List<${other.name}> ${kebab(other.name)}List = new java.util.ArrayList<>();`);
        // en DTO podrías exponer ids
        dtoFields.push(`  private java.util.List<Long> ${kebab(other.name)}Ids = new java.util.ArrayList<>();`);
      } else {
        // soy MANY -> fk hacia source
        fields.push(`  @ManyToOne\n  @JoinColumn(name="${kebab(source.name)}_id")\n  private ${source.name} ${source.name.charAt(0).toLowerCase() + source.name.slice(1)};`);
        dtoFields.push(`  private Long ${kebab(source.name)}Id;`);
      }
    } else if (type === "MANY_TO_ONE") {
      // soy MANY -> FK a other
      fields.push(`  @ManyToOne\n  @JoinColumn(name="${kebab(other.name)}_id")\n  private ${other.name} ${other.name.charAt(0).toLowerCase() + other.name.slice(1)};`);
      dtoFields.push(`  private Long ${kebab(other.name)}Id;`);
    } else if (type === "MANY_TO_MANY") {
      // dueñ@: el que es source
      if (iAmSource) {
        fields.push(`  @ManyToMany\n  @JoinTable(name="${kebab(cls.name)}_${kebab(other.name)}", joinColumns=@JoinColumn(name="${kebab(cls.name)}_id"), inverseJoinColumns=@JoinColumn(name="${kebab(other.name)}_id"))\n  private java.util.Set<${other.name}> ${kebab(other.name)}Set = new java.util.HashSet<>();`);
        dtoFields.push(`  private java.util.List<Long> ${kebab(other.name)}Ids = new java.util.ArrayList<>();`);
      }
    }
  }

  return { entityFields: fields, dtoFields };
}

/** ====== Generador ZIP ====== */
export async function generarSpringBootProyecto(model: Model, userOptions?: Options) {
  const opts = { ...DEFAULT_OPTS, ...(userOptions || {}) };
  const zip = new JSZip();

  const base = `${opts.artifactId}/`;
  const mainJava = `${base}src/main/java/`;
  const mainRes = `${base}src/main/resources/`;
  const pkgPath = `${opts.packageBase.replace(/\./g, "/")}/`;

  // POM y app props
  zip.file(`${base}pom.xml`, tplPomXml(opts));
  zip.file(`${mainRes}application.properties`, tplApplicationProperties(opts));
  zip.file(`${mainJava}${pkgPath}AppApplication.java`, tplApplicationClass(opts.packageBase));

  // Índices
  const classesById = Object.fromEntries(model.classes.map(c => [c.id, c]));
  const relsByClass: Record<string, Relationship[]> = {};
  model.classes.forEach(c => (relsByClass[c.id] = []));
  model.rels.forEach(r => {
    if (relsByClass[r.sourceId]) relsByClass[r.sourceId].push(r);
    if (relsByClass[r.targetId]) relsByClass[r.targetId].push(r);
  });

  // Herencia: detectar bases
  const bases = new Set<string>();
  model.rels.filter(r => r.kind === "generalization").forEach(r => {
    // source -> subclase, target -> superclase (convención común en StarUML)
    bases.add(r.targetId);
  });

  // Generar por clase
  for (const cls of model.classes) {
    const { entityFields, dtoFields } = relationFields(opts.packageBase, { classes: model.classes, rels: model.rels }, cls);

    // Entity
    zip.file(
      `${mainJava}${pkgPath}domain/${cls.name}.java`,
      tplEntity(opts.packageBase, cls, entityFields, bases.has(cls.id))
    );

    // Repo
    zip.file(
      `${mainJava}${pkgPath}repository/${cls.name}Repository.java`,
      tplRepository(opts.packageBase, cls.name)
    );

    // DTO
    zip.file(
      `${mainJava}${pkgPath}dto/${cls.name}Dto.java`,
      tplDto(opts.packageBase, cls, dtoFields)
    );

    // Mapper
    zip.file(
      `${mainJava}${pkgPath}mapper/${cls.name}Mapper.java`,
      tplMapper(opts.packageBase, cls.name)
    );

    // Service
    zip.file(
      `${mainJava}${pkgPath}service/${cls.name}Service.java`,
      tplService(opts.packageBase, cls.name)
    );

    // Controller
    zip.file(
      `${mainJava}${pkgPath}controller/${cls.name}Controller.java`,
      tplController(opts.packageBase, cls.name)
    );
  }

  // Postman collection
  zip.file(
    `${base}postman/collection.json`,
    tplPostmanCollection("http://localhost:8080", model.classes.map(c => c.name))
  );

  const blob = await zip.generateAsync({ type: "blob" });
  saveAs(blob, `${opts.artifactId}.zip`);
}
